import { Annotation, StateGraph } from "@langchain/langgraph";
import { getTopAdsByReach, getCompanyName } from './helpers';
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { HumanMessage } from "@langchain/core/messages";
import { adStructureSchema, layerSchema } from "./structures"
import { ChatOpenAI } from "@langchain/openai";
import { generateImage, uploadAdToAPI, sendImageToSlack } from "./helpers"
import dotenv from 'dotenv';

dotenv.config();

const stateSchema = Annotation.Root({
    companyId: Annotation<number>,
    companyName: Annotation<string>,
    exampleAds: Annotation<string[]>,
    fullAdDescription: Annotation<string>,
    layers: Annotation<object[]>,
    backgroundDescription: Annotation<string>,
    imageString: Annotation<string>,
});

async function setupNode(state: typeof stateSchema.State) {
    const exampleAds = await getTopAdsByReach(state.companyId);
    const companyName = await getCompanyName(state.companyId);
    return {companyName: companyName, exampleAds: exampleAds};
}

async function generateFullAdDescriptionNode(state: typeof stateSchema.State) {
    const fullAdDescriptionAgent = createReactAgent({
        llm: new ChatOpenAI({ model: "gpt-4.1"}),
        tools: [],
        prompt:
          `
          # Role
          You are a world class creative copy writer that has a talent for creating ads in structured format. Your role is to create structured ad descriptions of ads so that the resulting ad can be generated by AI. You will be provided with example ad descriptions of a company. The ads you create via the structured ad descriptions should be new but at the same time should look like someone from the company had created them.
    
          # Instructions
          Follow the following steps to create a single structured ad description:
          1. Receive a list of image descriptions of the best ads of the company from the input message.
          2. Analyze all these ad descriptions in detail to understand what style, wording, branding and psychological hooks the company uses for its ads.
          3. Use exactly the same style, wording, branding and psychological hooks as in the given ads of the company to come up with a creative new ad concept. Create a detailed new ad description in structured format as defined below. Think about a background image for the ad and text and rect layers that are on top of the background. Use the provided example to understand what content the background image should contain. Don't just understand the background image as a boring background but rather as everything that is in the ad that is not text or rect shapes. That means that e.g. if the ad shows images of the product or complex icons or symbols that cannot be created with the rect or text layer items, then this would be part of the background image instead. The background should not contain any text.
          4. Once you have created the output, go through the all the rules one by one to check if the output follows all the rules. Make adjustments if necessary. It is highly important that the background image description does not contain any text. Use the Think_Tool to check if all the rules are fulfilled.
          5. Go through the sourceImage description in detail to make sure it doe not contain any element descriptions which are already in the layers list. Delete any elements from the sourceImage description that are already in the layers list.
          6. Only return exaclty one structured ad description of the final ad as output and nothing else. Use the output_parser to create the json. Only return the structured json object as output so that it can directly be copied into the AI. Do not write anything before or after the json code, just return the json. Never return the thought of chain, only return the final json that defines the structured ad description.
    
          # Rules
          - Each ad is defined by its width and height dimensions, a background image (sourceImage) and text and rect items that are on top of the background image
          - The width and height of the ad should always be 1024.
          - The ad should always have one background image
          - The ad should always contain one CTA button that is created by combining a rounded rect shape item with a text item in the layers
          - Pay special attention to the x and y coordinates and the width and height of all layer elements in the list to make sure that the overall ad design looks nice
          - Background images should NEVER contain any text, all text has to be created via text items in the layers.
          - Background images are allowed to have rectangular shapes, only use rect shapes in the layers if the shapes are very simple (e.g. background of a CTA button, background of a headline, background of a rounded badge on the ad)
          - Circles can be created by using a rect shape item with a corresponding border radius
          - Before you give the final output, you have to make sure that you stretch the height of the text elements by 50% because the text will not be shown in the box if the text box is too small for the text - try to avoid this by increasing the height of the text layers
          - The background image should always fully fill the entire background and not be white or transparent. It is important that the text and rect shapes can be seen on the background so e.g. a white text on a white background would not work
    
          # Output Format
    
          ## Overall Ouptut Format
          Always return the output as a json in the following format:
    
          {
              "width": [placeholder for an integer number that represents the pixel width of the entire ad],
              "height": [placeholder for an integer number that represents the pixel height of the entire ad],
              "sourceImage": [placeholder for a string that is an image_description of the background image],
              "layers": [placeholder for list of text and rect layers]
          }
    
    
          ## Format of sourceImage string
    
          The souceImage should always be string that has the following format:
    
          <format of image_description>
          - You *MUST* accurately distinguish between **Photorealistic 3D Renders/Photos** (showing realistic materials, lighting, shadows) and **Flat Vector Illustrations/Icons** (using solid colors, sharp edges, no realistic shading).
          - **VERIFY ALL DETAILS METICULOUSLY AGAINST THE CURRENT IMAGE.** Pay extreme attention to counts, colors, text, shapes, and positions.
    
          **Required Details (Describe with Extreme Precision):**
    
          1. **Overall Canvas & Background:**
              - **Background Description:** Describe the background type (e.g., gradient). Specify *precise descriptive* color names (e.g., 'vibrant medium yellow', 'deep navy blue'). **Avoid hex codes.** For gradients, describe start/end colors, direction (e.g., linear top-to-bottom), and intensity. Note any subtle textures or noise. **Verify color accuracy.**
          2. **Layout & Composition:**
              - **Overall Arrangement:** Describe the placement of major elements using simple relative terms ONLY (e.g., 'Logo top-left', 'Headline centered below Logo', 'Panels centered horizontally below Headline', 'Badge to the right of Panels lower half', 'Swipe Up elements centered at bottom edge'). Avoid complex zones or grids.
              - **Spacing:** Describe general spacing (e.g., elements are distinct with clear negative space).
          3. **Detailed Element List:** Describe *each* distinct visual element below as a separate item in a list. For each element:
              - **A. Identification:** What is the element? (e.g., "Logo," "Solar Panel Group," "Price Badge," "Swipe Up Icon").
              - **B. Style & Realism (STATE FIRST & CLEARLY):** **CRITICAL** - Is this element:
                  - **Photorealistic 3D Render/Photograph:** (Emphasize realistic materials, textures, lighting, highlights, shadows indicating form in section C).
                  - **Flat Vector Illustration/Icon:** (Emphasize solid color blocks, sharp edges, no realistic shading in section C).
              - **C. Appearance & Details:**
                  - **Shape & Form:** Describe its geometry.
                  - **Color(s):** Specify *exact descriptive* color names for *all* parts (e.g., "Logo is dark navy blue"). **Meticulously check all components.**
                  - **Texture & Material:** Describe perceived surface (matte plastic, glossy metal with reflections, textured solar cells, flat color).
                  - **Specific Features:** **Exhaustively list *all* details:** patterns (e.g., solar cell grid lines), small graphical elements.
                  - **Lighting (for Renders/Photos):** Describe visible highlights, shadows, reflections *on the object itself* indicating form and light source direction. State "Flat graphic lighting" if applicable.
              - **D. Verification Checks (Answer Explicitly):**
                  - **Element Count (if applicable):** State the *exact number* visible (e.g., "Verified Panel Count: 3"). If not applicable, state N/A.
                  - **Logo Dot Color (for Logo only):** State the *exact descriptive color* (e.g., "Verified Logo Dot Color: Orange"). If not Logo, state N/A.
                  - **Border Present (Yes/No):** Does this specific element have a visible border/outline?
                  - **Shadow Present (Yes/No):** Does this specific element have a distinct drop shadow or internal shading suggesting depth (beyond realistic form shading on renders)?
              - **E. Position & Size:** Reiterate its specific location using relative positioning (as per point 2) and its approximate size relative to the canvas width/height or other elements.
          4. **Overall Impression:**
              - **Dominant Medium/Mix:** Summarize the mix (e.g., "Mix of photorealistic product renders against a gradient background with flat graphic icons").
              - **Aesthetic:** (e.g., Clean, modern, corporate, tech-focused).
              - **Quality:** (e.g., High-resolution, sharp renders, clean text).
          Generate the description as a **structured Markdown list**. Start with 'Overall Canvas & Background' and 'Layout & Composition'. Then, create a bullet point list under 'Detailed Element List', with each bullet point representing *one distinct visual element* and containing all its specified details (A-F). Finish with 'Overall Impression'.
          </format of image_description>
    
          ## Format of list of layers
    
          The "layers" key in the final output json should have the following value: a JSON list of segmentation items where each entry is either of type "text" or type "rect".
    
          Each item of type "text" contains the following information:
            - type of segmentation in the key "type" (this should always have the value "text")
            - text content within the mask in the key "text"
            - x coordinate of the box in the key "x"
            - y coordinate of the box in the key "y"
            - width of the box in the key "width"
            - height of the box in the key "height"
            - size of the font in the key "fontSize"
            - color of the text as a hex code in the key "color"
            - alignment (e.g. "center") of the text in the key "align"
    
            Each item of type "rect" contains the following information:
            - type of segmentation in the key "type" (this should always have the value "rect")
            - x coordinate of the box in the key "x"
            - y coordinate of the box in the key "y"
            - width of the box in the key "width"
            - height of the box in the key "height"
            - fill color of the box as a hex code in the key "fill"
            - stroke color of the box as a hex code in the key "stroke"
            - stroke width of the box in the key "strokeWidth"
            - rotation of the box in the key "rotation"
            - border radius of the box in the key "borderRadius"
    
          Attribute Accuracy: Coordinates, width, height, colors, font sizes, border radii, and stroke widths (in absolute pixels) must be meticulously determined with high precision. The x and y coordinates should be pixel values as integers and need to be put in relation to the total width and height of the ad (e.g. if total ad height = 1024, then y = 512 will be the height in the middle of the picture.) Alle elements have to be within the frame that is defined by the width and height of the ad.
    
    
          # Examples
          Here are examples outputs of structured ad descriptions:
    
          <example>
          {
            "width": 1024,
            "height": 1024,
            "sourceImage": [placeholder for string of detailed background description],
            "layers": [
              {
                "type": "text",
                "text": "Spitzenqualität vom Solar-Testsieger",
                "x": 38,
                "y": 240,
                "width": 335,
                "height": 60,
                "fontSize": 40,
                "color": "#F7C93D",
                "align": "left"
              },
              {
                "type": "text",
                "text": "Finden Sie jetzt heraus wie viel Sie sparen können.",
                "x": 38,
                "y": 300,
                "width": 375,
                "height": 50,
                "fontSize": 25,
                "color": "#FFFFFF",
                "align": "left"
              },
              {
                "type": "rect",
                "x": 400,
                "y": 500,
                "width": 20,
                "height": 20,
                "fill": "#30A1C0",
                "stroke": "#30A1C0",
                "strokeWidth": 0,
                "rotation": 0,
                "borderRadius": 15
              }
            ]
          }
          </example>
          `
      });
      
      const message = new HumanMessage({
        content: [
          {
            type: "text",
            text: "Please return the image description of the new ad. Attached you find a list of image descriptions of the best ads of the company.",
          },
          {
            type:"text",
            text: state.exampleAds.join("\n\n"),
          }
        ],
      });
      
      // Now it's time to use!
      const endState = await fullAdDescriptionAgent.invoke(
        { messages: [message] },
      );
      
      const imageDescription = endState.messages[endState.messages.length - 1].content;
      return {fullAdDescription : imageDescription}
}

async function extractAdLayerNode(state: typeof stateSchema.State) {
  const extractAdLayerAgent = createReactAgent({
      llm: new ChatOpenAI({ model: "gpt-4.1"}),
      tools: [],
      responseFormat: layerSchema,
      prompt:
        `
        # Role
        You are a meticulous AI assistant specializing in parsing structured ad descriptions. Your role is to extract text and rectangle layer information from a given ad's image description. You will be provided with a detailed image description of a complete ad.

        # Instructions
        Follow these steps to extract the layers:
        1. Receive a detailed image description of an ad from the input message.
        2. Analyze the image description to identify all distinct text elements and simple rectangular shapes that function as layers (e.g., text elements, headlines, button text, backgrounds for text, rounded buttons).
        3. For each identified text and rect element, extract its properties (type, text content (for text), x, y, width, height, colors, font size (for text), alignment (for text), fill/stroke (for rects), border radius (for rects), etc.) as defined in the output format.
        4. Ensure that the extracted layer information accurately reflects the details provided in the input image description.
        5. Only return a JSON object containing the list of extracted layers as output and nothing else.

        # Rules
        - Each layer must be either of type "text" or type "rect".
        - The give ad is 1024 x 1024 pixels and the layers will be put into a rectangular frame of the width and height of the ad. Width and height are both 1024 pixels. The coordinates have to match that.
        - Pay special attention to the x and y coordinates and the width and height of all layer elements to ensure they are accurately extracted from the description.
        - All text content must be extracted as text items in the layers. The background image description itself should ideally not contain text that is meant to be a layer.
        - Simple rectangular shapes (e.g., background of a CTA button, background of a headline, rounded badges) should be extracted as rect items.
        - Circles can be created by using a rect shape item with a corresponding border radius; extract these as rects if present.
        - Attribute Accuracy: Coordinates, width, height, colors, font sizes, border radii, and stroke widths (in absolute pixels) must be meticulously determined with high precision based on the provided image description.
        - If information for certain attributes of elements are not given in the image description, you have to infer them based on the rest of the image description so that they perfectly fit into the design, style and layout of the ad

        # Output Format
        Always return the output as a JSON object in the following format, containing only the "layers" key:

        {
            "layers": [placeholder for list of text and rect layers]
        }

        ## Format of list of layers

        The "layers" key in the final output json should have the following value: a JSON list of segmentation items where each entry is either of type "text" or type "rect".

        Each item of type "text" contains the following information:
          - type of segmentation in the key "type" (this should always have the value "text")
          - text content within the mask in the key "text"
          - x coordinate of the box in the key "x"
          - y coordinate of the box in the key "y"
          - width of the box in the key "width"
          - height of the box in the key "height"
          - size of the font in the key "fontSize"
          - color of the text as a hex code in the key "color"
          - alignment (e.g. "center") of the text in the key "align"

          Each item of type "rect" contains the following information:
          - type of segmentation in the key "type" (this should always have the value "rect")
          - x coordinate of the box in the key "x"
          - y coordinate of the box in the key "y"
          - width of the box in the key "width"
          - height of the box in the key "height"
          - fill color of the box as a hex code in the key "fill"
          - stroke color of the box as a hex code in the key "stroke"
          - stroke width of the box in the key "strokeWidth"
          - rotation of the box in the key "rotation"
          - border radius of the box in the key "borderRadius"

        # CRITICAL JSON FORMAT REQUIREMENTS
        - Use ONLY double quotes for all strings
        - All property names must be in double quotes
        - No single quotes anywhere
        - No trailing commas
        - Return valid JSON only
        - No additional text before or after JSON

        # Example Output
        {
          "layers": [
            {
              "type": "text",
              "text": "Amazing New Product",
              "x": /* extracted or estimated x */,
              "y": /* extracted or estimated y */,
              "width": /* extracted or estimated width */,
              "height": /* extracted or estimated height */,
              "fontSize": /* extracted or estimated fontSize */,
              "color": "#FFFFFF",
              "align": "center"
            },
            {
              "type": "rect",
              "x": /* extracted or estimated x for CTA background */,
              "y": /* extracted or estimated y for CTA background */,
              "width": /* extracted or estimated width for CTA background */,
              "height": /* extracted or estimated height for CTA background */,
              "fill": "#FFFF00", // Example hex for vibrant medium yellow
              "stroke": "#FFFF00",
              "strokeWidth": 0,
              "rotation": 0,
              "borderRadius": /* extracted or estimated borderRadius */
            },
            {
              "type": "text",
              "text": "Learn More",
              "x": /* extracted or estimated x for CTA text */,
              "y": /* extracted or estimated y for CTA text */,
              "width": /* extracted or estimated width for CTA text */,
              "height": /* extracted or estimated height for CTA text */,
              "fontSize": /* extracted or estimated fontSize for CTA text */,
              "color": "#000080", // Example hex for deep navy blue
              "align": "center"
            }
          ]
        }
        `
    });
    
    const message = new HumanMessage({
      content: [
        {
          type: "text",
          text: "Please return the layers of the new ad. Attached you find a description of the new ad.",
        },
        {
          type:"text",
          text: state.fullAdDescription,
        }
      ],
    });
    
    const endState = await extractAdLayerAgent.invoke(
      { messages: [message] },
    );
    
    let content = endState.messages[endState.messages.length - 1].content as string;
    
    // Sanitize the JSON response
    content = content.trim();
    // Remove any markdown code block markers
    content = content.replace(/```json\s*|```\s*/g, '');
    // Replace single quotes with double quotes
    content = content.replace(/'/g, '"');
    // Add quotes around unquoted property names
    content = content.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
    
    try {
        const parsedContent = JSON.parse(content);
        //console.log('Successfully parsed layers:', parsedContent.layers);
        return { layers: parsedContent.layers };
    } catch (parseError) {
        console.error('JSON parsing failed even after sanitization:', parseError);
        console.error('Content that failed to parse:', content);
        
        // Fallback: return empty layers array
        return { layers: [] };
    }
}

async function extractBackgroundDescriptionNode(state: typeof stateSchema.State) {
  const extractBackgroundAgent = createReactAgent({
      llm: new ChatOpenAI({ model: "gpt-4.1"}),
      tools: [],
      prompt:
        `
        # Role
        You are an AI assistant that creates precise background image descriptions for an image generation AI. Your task is to describe only the visual elements that should form the background of an ad, based on a full ad description and a list of overlay layers. The image generation AI has no context of these layers.

        # Instructions
        1. Analyze the provided full ad description and the list of extracted layers.
        2. Identify all visual elements in the full ad description that are NOT part of the extracted layers.
        3. Create a description of these background-only elements. This description will be directly used by an image generation AI.
        4. Describe the background as if you are instructing the image generator on what to draw.

        # Rules for Description Content:
        - Focus SOLELY on what IS VISIBLE in the background.
        - Do NOT mention any elements that were part of the original description but are now in the layers (e.g., "text was removed").
        - Do NOT explain *why* certain areas are empty or have specific features (e.g., "to prevent visual conflicts").
        - Describe the overall canvas and its main background treatment (e.g., "A 1024x1024 canvas with a vertical gradient from vibrant medium yellow (#FFE138) at the top to pale yellow (#FFF9E6) at the bottom.").
        - For any distinct background objects (images, complex graphics, specific color areas), specify:
            - Their appearance (e.g., "A subtle, light gray product silhouette").
            - Their precise location and size using x, y, width, height (e.g., "located at x: 50, y: 100, width: 200, height: 150").
            - Specific colors (e.g., "using color #CCCCCC").
        - If there are areas within the background that should be empty or have a specific uniform color to ensure later overlays will be clear, describe these areas directly with their coordinates and the required visual characteristic (e.g., "An area at x: 300, y: 200, width: 400, height: 100 should be a solid, pale yellow (#FFF9E6).").

        # Output Format:
        - Return ONLY the background description as plain text.
        - The description should be clear, concise, and structured.
        - Use simple language. Start with the overall background, then detail specific elements and their properties (location, size, color).
        - Example Snippet: "The background is a solid deep blue (#000080). A circular light blue (#ADD8E6) shape is at x: 50, y: 50, width: 100, height: 100. An area at x: 200, y: 200, width: 300, height: 50 is plain white (#FFFFFF)."
        `
    });
    
    const message = new HumanMessage({
      content: [
        {
          type: "text",
          text: "Please analyze the full ad description and extracted layers, then return a clean background description that excludes all elements already represented in the layers.",
        },
        {
          type: "text",
          text: `Full Ad Description:\n${state.fullAdDescription}`,
        },
        {
          type: "text",
          text: `Extracted Layers:\n${JSON.stringify(state.layers, null, 2)}`,
        }
      ],
    });
    
    const endState = await extractBackgroundAgent.invoke(
      { messages: [message] },
    );
    
    const backgroundDescription = endState.messages[endState.messages.length - 1].content as string;
    return { backgroundDescription: backgroundDescription };
}

async function uploadAdNode(state: typeof stateSchema.State) {
    // Create background image prompt using the separated background description
    const backgroundImagePrompt = `Generate an image based on the following image description: ${state.backgroundDescription}.`;
    
    const image_base64 = await generateImage(backgroundImagePrompt);
    //const image_base64_FullAd = await generateImage(state.fullAdDescription);
    //sendImageToSlack(image_base64_FullAd, 'Here is the image of the full ad:');
    // Merge the separated data for the API call
    const mergedAdData = {
        width: 1024,
        height: 1024,
        layers: state.layers
    };
    
    await uploadAdToAPI(mergedAdData, image_base64 as string);
    return {imageString: image_base64};
}

export const graph = new StateGraph({
    stateSchema: stateSchema
})
    .addNode("setupNode", setupNode)
    .addNode("generateFullAdDescriptionNode", generateFullAdDescriptionNode)
    .addNode("extractAdLayerNode", extractAdLayerNode)
    .addNode("extractBackgroundDescriptionNode", extractBackgroundDescriptionNode)
    .addNode("uploadAdNode", uploadAdNode)
    .addEdge("__start__", "setupNode")
    .addEdge("setupNode", "generateFullAdDescriptionNode")
    .addEdge("generateFullAdDescriptionNode", "extractAdLayerNode")
    .addEdge("extractAdLayerNode", "extractBackgroundDescriptionNode")
    .addEdge("extractBackgroundDescriptionNode", "uploadAdNode")
    .addEdge("uploadAdNode", "__end__")
    .compile();

    