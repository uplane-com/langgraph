import { Annotation, StateGraph } from "@langchain/langgraph";
import { getTopAdsByReach, getCompanyName } from './helpers';
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { HumanMessage } from "@langchain/core/messages";
import { adStructureSchema } from "./structures"
import { ChatOpenAI } from "@langchain/openai";
import { generateImage, uploadAdToAPI } from "./helpers"
import dotenv from 'dotenv';

dotenv.config();

const stateSchema = Annotation.Root({
    companyId: Annotation<number>,
    companyName: Annotation<string>,
    exampleAds: Annotation<string[]>,
    structuredAd: Annotation<object>,
});

async function setupNode(state) {
    const exampleAds = await getTopAdsByReach(state.companyId);
    const companyName = await getCompanyName(state.companyId);
    return {companyName: companyName, exampleAds: exampleAds};
}

async function generateStructuredAdAgentNode(state) {
    const StructuredAdAgent = createReactAgent({
        llm: new ChatOpenAI({ model: "gpt-4.1", temperature: 0.5}),
        tools: [],
        responseFormat: adStructureSchema,
        prompt:
          `# Role
            You are a world class creative copy writer that has a talent for creating ads in structured format. Your role is to create structured ad descriptions of ads so that the resulting ad can be generated by AI. You will be provided with example ad descriptions of a company. The ads you create via the structured ad descriptions should be new but at the same time should look like someone from the company had created them.
      
            # Instructions
            Follow the following steps to create a single structured ad description:
            1. Receive a list of image descriptions of the best ads of the company from the input message.
            2. Analyze all these ad descriptions in detail to understand what style, wording, branding and psychological hooks the company uses for its ads.
            3. Use exactly the same style, wording, branding and psychological hooks as in the given ads of the company to come up with a creative new ad concept. Create a detailed new ad description in structured format as defined below. Think about a background image for the ad and text and rect layers that are on top of the background. Use the provided example to understand what content the background image should contain. Don't just understand the background image as a boring background but rather as everything that is in the ad that is not text or rect shapes. That means that e.g. if the ad shows images of the product or complex icons or symbols that cannot be created with the rect or text layer items, then this would be part of the background image instead. The background should not contain any text.
            4. Once you have created the output, go through the all the rules one by one to check if the output follows all the rules. Make adjustments if necessary. It is highly important that the background image description does not contain any text. Use the Think_Tool to check if all the rules are fulfilled.
            5. Go through the sourceImage description in detail to make sure it doe not contain any element descriptions which are already in the layers list. Delete any elements from the sourceImage description that are already in the layers list.
            6. Only return exaclty one structured ad description of the final ad as output and nothing else. Use the output_parser to create the json. Only return the structured json object as output so that it can directly be copied into the AI. Do not write anything before or after the json code, just return the json. Never return the thought of chain, only return the final json that defines the structured ad description.
      
            # Rules
            - Each ad is defined by its width and height dimensions, a background image (sourceImage) and text and rect items that are on top of the background image
            - The width and height of the ad should always be 1024.
            - The ad should always have one background image
            - The ad should always contain one CTA button that is created by combining a rounded rect shape item with a text item in the layers
            - Pay special attention to the x and y coordinates and the width and height of all layer elements in the list to make sure that the overall ad design looks nice
            - Background images should NEVER contain any text, all text has to be created via text items in the layers.
            - Background images are allowed to have rectangular shapes, only use rect shapes in the layers if the shapes are very simple (e.g. background of a CTA button, background of a headline, background of a rounded badge on the ad)
            - Circles can be created by using a rect shape item with a corresponding border radius
            - Before you give the final output, you have to make sure that you stretch the height of the text elements by 50% because the text will not be shown in the box if the text box is too small for the text - try to avoid this by increasing the height of the text layers
            - The background image should always fully fill the entire background and not be white or transparent. It is important that the text and rect shapes can be seen on the background so e.g. a white text on a white background would not work
      
            # Output Format
      
            ## Overall Ouptut Format
            Always return the output as a json in the following format:
      
            {
                "width": [placeholder for an integer number that represents the pixel width of the entire ad],
                "height": [placeholder for an integer number that represents the pixel height of the entire ad],
                "sourceImage": [placeholder for a string that is an image_description of the background image],
                "layers": [placeholder for list of text and rect layers]
            }
      
      
            ## Format of sourceImage string
      
            The souceImage should always be string that has the following format:
      
            <format of image_description>
            - You *MUST* accurately distinguish between **Photorealistic 3D Renders/Photos** (showing realistic materials, lighting, shadows) and **Flat Vector Illustrations/Icons** (using solid colors, sharp edges, no realistic shading).
            - **VERIFY ALL DETAILS METICULOUSLY AGAINST THE CURRENT IMAGE.** Pay extreme attention to counts, colors, text, shapes, and positions.
      
            **Required Details (Describe with Extreme Precision):**
      
            1. **Overall Canvas & Background:**
                - **Background Description:** Describe the background type (e.g., gradient). Specify *precise descriptive* color names (e.g., 'vibrant medium yellow', 'deep navy blue'). **Avoid hex codes.** For gradients, describe start/end colors, direction (e.g., linear top-to-bottom), and intensity. Note any subtle textures or noise. **Verify color accuracy.**
            2. **Layout & Composition:**
                - **Overall Arrangement:** Describe the placement of major elements using simple relative terms ONLY (e.g., 'Logo top-left', 'Headline centered below Logo', 'Panels centered horizontally below Headline', 'Badge to the right of Panels lower half', 'Swipe Up elements centered at bottom edge'). Avoid complex zones or grids.
                - **Spacing:** Describe general spacing (e.g., elements are distinct with clear negative space).
            3. **Detailed Element List:** Describe *each* distinct visual element below as a separate item in a list. For each element:
                - **A. Identification:** What is the element? (e.g., "Logo," "Solar Panel Group," "Price Badge," "Swipe Up Icon").
                - **B. Style & Realism (STATE FIRST & CLEARLY):** **CRITICAL** - Is this element:
                    - **Photorealistic 3D Render/Photograph:** (Emphasize realistic materials, textures, lighting, highlights, shadows indicating form in section C).
                    - **Flat Vector Illustration/Icon:** (Emphasize solid color blocks, sharp edges, no realistic shading in section C).
                - **C. Appearance & Details:**
                    - **Shape & Form:** Describe its geometry.
                    - **Color(s):** Specify *exact descriptive* color names for *all* parts (e.g., "Logo is dark navy blue"). **Meticulously check all components.**
                    - **Texture & Material:** Describe perceived surface (matte plastic, glossy metal with reflections, textured solar cells, flat color).
                    - **Specific Features:** **Exhaustively list *all* details:** patterns (e.g., solar cell grid lines), small graphical elements.
                    - **Lighting (for Renders/Photos):** Describe visible highlights, shadows, reflections *on the object itself* indicating form and light source direction. State "Flat graphic lighting" if applicable.
                - **D. Verification Checks (Answer Explicitly):**
                    - **Element Count (if applicable):** State the *exact number* visible (e.g., "Verified Panel Count: 3"). If not applicable, state N/A.
                    - **Logo Dot Color (for Logo only):** State the *exact descriptive color* (e.g., "Verified Logo Dot Color: Orange"). If not Logo, state N/A.
                    - **Border Present (Yes/No):** Does this specific element have a visible border/outline?
                    - **Shadow Present (Yes/No):** Does this specific element have a distinct drop shadow or internal shading suggesting depth (beyond realistic form shading on renders)?
                - **E. Position & Size:** Reiterate its specific location using relative positioning (as per point 2) and its approximate size relative to the canvas width/height or other elements.
            4. **Overall Impression:**
                - **Dominant Medium/Mix:** Summarize the mix (e.g., "Mix of photorealistic product renders against a gradient background with flat graphic icons").
                - **Aesthetic:** (e.g., Clean, modern, corporate, tech-focused).
                - **Quality:** (e.g., High-resolution, sharp renders, clean text).
            Generate the description as a **structured Markdown list**. Start with 'Overall Canvas & Background' and 'Layout & Composition'. Then, create a bullet point list under 'Detailed Element List', with each bullet point representing *one distinct visual element* and containing all its specified details (A-F). Finish with 'Overall Impression'.
            </format of image_description>
      
            ## Format of list of layers
      
            The "layers" key in the final output json should have the following value: a JSON list of segmentation items where each entry is either of type "text" or type "rect".
      
            Each item of type "text" contains the following information:
              - type of segmentation in the key "type" (this should always have the value "text")
              - text content within the mask in the key "text"
              - x coordinate of the box in the key "x"
              - y coordinate of the box in the key "y"
              - width of the box in the key "width"
              - height of the box in the key "height"
              - size of the font in the key "fontSize"
              - color of the text as a hex code in the key "color"
              - alignment (e.g. "center") of the text in the key "align"
      
              Each item of type "rect" contains the following information:
              - type of segmentation in the key "type" (this should always have the value "rect")
              - x coordinate of the box in the key "x"
              - y coordinate of the box in the key "y"
              - width of the box in the key "width"
              - height of the box in the key "height"
              - fill color of the box as a hex code in the key "fill"
              - stroke color of the box as a hex code in the key "stroke"
              - stroke width of the box in the key "strokeWidth"
              - rotation of the box in the key "rotation"
              - border radius of the box in the key "borderRadius"
      
            Attribute Accuracy: Coordinates, width, height, colors, font sizes, border radii, and stroke widths (in absolute pixels) must be meticulously determined with high precision. The x and y coordinates should be pixel values as integers and need to be put in relation to the total width and height of the ad (e.g. if total ad height = 1024, then y = 512 will be the height in the middle of the picture.) Alle elements have to be within the frame that is defined by the width and height of the ad.
      
      
            # Examples
            Here are examples outputs of structured ad descriptions:
      
            <example>
            {
              "width": 1024,
              "height": 1024,
              "sourceImage": [placeholder for string of detailed background description],
              "layers": [
                {
                  "type": "text",
                  "text": "Spitzenqualität vom Solar-Testsieger",
                  "x": 38,
                  "y": 240,
                  "width": 335,
                  "height": 60,
                  "fontSize": 40,
                  "color": "#F7C93D",
                  "align": "left"
                },
                {
                  "type": "text",
                  "text": "Finden Sie jetzt heraus wie viel Sie sparen können.",
                  "x": 38,
                  "y": 300,
                  "width": 375,
                  "height": 50,
                  "fontSize": 25,
                  "color": "#FFFFFF",
                  "align": "left"
                },
                {
                  "type": "rect",
                  "x": 400,
                  "y": 500,
                  "width": 20,
                  "height": 20,
                  "fill": "#30A1C0",
                  "stroke": "#30A1C0",
                  "strokeWidth": 0,
                  "rotation": 0,
                  "borderRadius": 15
                }
              ]
            }
            </example>`
      });
      
      const message = new HumanMessage({
        content: [
          {
            type: "text",
            text: "Please return the structured ad. Attached you find a list of image descriptions of the best ads of the company.",
          },
          {
            type:"text",
            text: state.exampleAds.join("\n\n"),
          }
        ],
      });
      
      // Now it's time to use!
      const endState = await StructuredAdAgent.invoke(
        { messages: [message] },
        { configurable: { thread_id: "42" } },
      );
      
      const structuredOutput = endState.messages[endState.messages.length - 1];
      const structuredOutputMessage = structuredOutput.content;
      let answer = JSON.parse(structuredOutputMessage as string);
      return {structuredAd : answer}
}

async function uploadAdNode(state) {
    let backgroundImagePrompt = "Generate an image based on the following image description that is represented by the json below. The key sourceImage contains the background image. The layer items in the layers list should be placed on top of this background image:" + JSON.stringify(state.structuredAd) + "After you have generated the entire image, you have to do one more thing. Remove all items from the layers list from the image. The returned image should not contain any of the text elements or rect shapes from the layers list. It should not contain any text at all. You should leave a lot of free space at the spots where the layer items where located before you removed them so that if they were later added again, they woul not overlay with any other important image elements in the background. This highly important, rather leave more space then too little space. Return the image without these elements."
    let image_base64 = await generateImage(backgroundImagePrompt)
    uploadAdToAPI(state.structuredAd, image_base64)
}

export const graph = new StateGraph({
    stateSchema: stateSchema
})
    .addNode("setupNode", setupNode)
    .addNode("generateStructuredAdAgentNode", generateStructuredAdAgentNode)
    .addNode("uploadAdNode", uploadAdNode)
    .addEdge("__start__", "setupNode")
    .addEdge("setupNode", "generateStructuredAdAgentNode")
    .addEdge("generateStructuredAdAgentNode", "uploadAdNode")
    .addEdge("uploadAdNode", "__end__")
    .compile();


/*    
const result = await graph.invoke({
    companyId: 18
});

console.log(result);
*/